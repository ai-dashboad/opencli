import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:tray_manager/tray_manager.dart';
import 'package:window_manager/window_manager.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

/// è·¨å¹³å°ç³»ç»Ÿæ‰˜ç›˜æœåŠ¡
/// æ”¯æŒ macOS (èœå•æ )ã€Windows (ç³»ç»Ÿæ‰˜ç›˜)ã€Linux (ç³»ç»Ÿæ‰˜ç›˜)
class SystemTrayService with TrayListener {
  static const String _daemonStatusUrl = 'http://localhost:9875/status';
  Timer? _statusUpdateTimer;

  // Daemon çŠ¶æ€
  bool _isRunning = false;
  String _version = '0.0.0';
  int _uptimeSeconds = 0;
  double _memoryMb = 0.0;
  int _mobileClients = 0;
  int _totalRequests = 0;

  // Getters
  bool get isRunning => _isRunning;
  String get version => _version;
  String get uptimeFormatted => _formatUptime(_uptimeSeconds);
  String get memoryFormatted => '${_memoryMb.toStringAsFixed(1)} MB';
  int get mobileClients => _mobileClients;

  /// åˆå§‹åŒ–ç³»ç»Ÿæ‰˜ç›˜
  Future<void> initialize() async {
    try {
      // è®¾ç½®æ‰˜ç›˜ç›‘å¬å™¨
      trayManager.addListener(this);

      // è®¾ç½®æ‰˜ç›˜å›¾æ ‡
      await _setTrayIcon();

      // è®¾ç½®å·¥å…·æç¤º
      await trayManager.setToolTip('OpenCLI - Initializing...');

      // åˆ›å»ºæ‰˜ç›˜èœå•
      await _updateTrayMenu();

      // å¼€å§‹å®šæœŸæ›´æ–°çŠ¶æ€
      _startStatusUpdates();

      print('âœ… System tray initialized successfully');
    } catch (e) {
      print('âš ï¸  Failed to initialize system tray: $e');
    }
  }

  /// è®¾ç½®æ‰˜ç›˜å›¾æ ‡
  Future<void> _setTrayIcon() async {
    String iconPath;

    if (Platform.isMacOS) {
      // macOS ä½¿ç”¨æ¨¡æ¿å›¾æ ‡ï¼ˆè‡ªåŠ¨é€‚é…æ·±è‰²æ¨¡å¼ï¼‰
      iconPath = 'assets/tray_icon_macos_template.png';
    } else if (Platform.isWindows) {
      iconPath = 'assets/tray_icon_windows.ico';
    } else {
      // Linux
      iconPath = 'assets/tray_icon_linux.png';
    }

    try {
      await trayManager.setIcon(iconPath);
    } catch (e) {
      print('âš ï¸  Failed to set tray icon: $e');
      // å¦‚æœå›¾æ ‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å›¾æ ‡
      // è¿™é‡Œå¯ä»¥è€ƒè™‘ä½¿ç”¨å†…ç½®çš„é»˜è®¤å›¾æ ‡
    }
  }

  /// å¼€å§‹å®šæœŸæ›´æ–°çŠ¶æ€
  void _startStatusUpdates() {
    // ç«‹å³æ›´æ–°ä¸€æ¬¡
    _updateDaemonStatus();

    // æ¯ 3 ç§’æ›´æ–°ä¸€æ¬¡
    _statusUpdateTimer = Timer.periodic(
      const Duration(seconds: 3),
      (_) => _updateDaemonStatus(),
    );
  }

  /// æ›´æ–° Daemon çŠ¶æ€
  Future<void> _updateDaemonStatus() async {
    try {
      final response = await http.get(
        Uri.parse(_daemonStatusUrl),
      ).timeout(const Duration(seconds: 2));

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final daemon = data['daemon'] as Map<String, dynamic>;
        final mobile = data['mobile'] as Map<String, dynamic>;

        _isRunning = true;
        _version = daemon['version'] as String? ?? '0.0.0';
        _uptimeSeconds = daemon['uptime_seconds'] as int? ?? 0;
        _memoryMb = (daemon['memory_mb'] as num?)?.toDouble() ?? 0.0;
        _mobileClients = mobile['connected_clients'] as int? ?? 0;
        _totalRequests = daemon['total_requests'] as int? ?? 0;

        // æ›´æ–°æ‰˜ç›˜å·¥å…·æç¤º
        await trayManager.setToolTip(
          'OpenCLI - Running\n'
          'Uptime: $uptimeFormatted\n'
          'Memory: $memoryFormatted'
        );

        // æ›´æ–°æ‰˜ç›˜èœå•
        await _updateTrayMenu();
      } else {
        _handleDaemonOffline();
      }
    } catch (e) {
      _handleDaemonOffline();
    }
  }

  /// å¤„ç† Daemon ç¦»çº¿çŠ¶æ€
  void _handleDaemonOffline() {
    _isRunning = false;
    trayManager.setToolTip('OpenCLI - Daemon Offline');
  }

  /// æ›´æ–°æ‰˜ç›˜èœå•
  Future<void> _updateTrayMenu() async {
    final statusIcon = _isRunning ? 'ğŸŸ¢' : 'ğŸ”´';
    final statusText = _isRunning ? 'Running' : 'Offline';

    final menu = Menu(items: [
      // æ ‡é¢˜å’ŒçŠ¶æ€
      MenuItem(
        key: 'header',
        label: '$statusIcon OpenCLI - $statusText',
        disabled: true,
      ),
      MenuItem.separator(),

      // çŠ¶æ€ä¿¡æ¯
      MenuItem(
        key: 'version',
        label: 'Version: $_version',
        disabled: true,
      ),
      MenuItem(
        key: 'uptime',
        label: 'â±ï¸  Uptime: $uptimeFormatted',
        disabled: true,
      ),
      MenuItem(
        key: 'memory',
        label: 'ğŸ’¾ Memory: $memoryFormatted',
        disabled: true,
      ),
      MenuItem(
        key: 'clients',
        label: 'ğŸ“± Mobile Clients: $_mobileClients',
        disabled: true,
      ),
      MenuItem.separator(),

      // æ“ä½œèœå•
      MenuItem(
        key: 'ai_models',
        label: 'ğŸ¤– AI Models',
      ),
      MenuItem(
        key: 'dashboard',
        label: 'ğŸ“Š Open Dashboard',
      ),
      MenuItem(
        key: 'webui',
        label: 'ğŸŒ Open Web UI',
      ),
      MenuItem(
        key: 'settings',
        label: 'âš™ï¸  Settings',
      ),
      MenuItem.separator(),

      // åˆ·æ–°å’Œé€€å‡º
      MenuItem(
        key: 'refresh',
        label: 'â™»ï¸  Refresh',
      ),
      MenuItem(
        key: 'quit',
        label: 'âŒ Quit OpenCLI',
      ),
    ]);

    await trayManager.setContextMenu(menu);
  }

  /// æ ¼å¼åŒ–è¿è¡Œæ—¶é—´
  String _formatUptime(int seconds) {
    if (seconds < 60) {
      return '${seconds}s';
    } else if (seconds < 3600) {
      final mins = seconds ~/ 60;
      return '${mins}m';
    } else if (seconds < 86400) {
      final hours = seconds ~/ 3600;
      final mins = (seconds % 3600) ~/ 60;
      return '${hours}h ${mins}m';
    } else {
      final days = seconds ~/ 86400;
      final hours = (seconds % 86400) ~/ 3600;
      return '${days}d ${hours}h';
    }
  }

  /// æ‰˜ç›˜å›¾æ ‡ç‚¹å‡»äº‹ä»¶
  @override
  void onTrayIconMouseDown() {
    // åœ¨ Windows ä¸Šï¼Œå·¦é”®ç‚¹å‡»æ˜¾ç¤ºèœå•
    if (Platform.isWindows) {
      trayManager.popUpContextMenu();
    }
  }

  /// æ‰˜ç›˜å›¾æ ‡å³é”®ç‚¹å‡»äº‹ä»¶
  @override
  void onTrayIconRightMouseDown() {
    // åœ¨ macOS å’Œ Linux ä¸Šï¼Œå³é”®ç‚¹å‡»æ˜¾ç¤ºèœå•
    trayManager.popUpContextMenu();
  }

  /// æ‰˜ç›˜èœå•é¡¹ç‚¹å‡»äº‹ä»¶
  @override
  void onTrayMenuItemClick(MenuItem menuItem) {
    switch (menuItem.key) {
      case 'ai_models':
        _openAIModels();
        break;
      case 'dashboard':
        _openDashboard();
        break;
      case 'webui':
        _openWebUI();
        break;
      case 'settings':
        _openSettings();
        break;
      case 'refresh':
        _refresh();
        break;
      case 'quit':
        _quit();
        break;
    }
  }

  /// æ‰“å¼€ AI Models
  void _openAIModels() {
    print('ğŸ“ Opening AI Models...');
    // TODO: å®ç°æ‰“å¼€ AI Models é¡µé¢
    _showMainWindow();
  }

  /// æ‰“å¼€ Dashboard
  void _openDashboard() {
    print('ğŸ“ Opening Dashboard...');
    // TODO: å®ç°æ‰“å¼€ Dashboard
    _openUrl('http://localhost:3000/dashboard');
  }

  /// æ‰“å¼€ Web UI
  void _openWebUI() {
    print('ğŸ“ Opening Web UI...');
    _openUrl('http://localhost:3000');
  }

  /// æ‰“å¼€è®¾ç½®
  void _openSettings() {
    print('ğŸ“ Opening Settings...');
    _showMainWindow();
  }

  /// åˆ·æ–°çŠ¶æ€
  void _refresh() {
    print('â™»ï¸  Refreshing status...');
    _updateDaemonStatus();
  }

  /// é€€å‡ºåº”ç”¨
  void _quit() {
    print('ğŸ‘‹ Quitting OpenCLI...');
    _cleanup();
    exit(0);
  }

  /// æ˜¾ç¤ºä¸»çª—å£
  Future<void> _showMainWindow() async {
    await windowManager.show();
    await windowManager.focus();
  }

  /// æ‰“å¼€ URL
  void _openUrl(String url) {
    // TODO: å®ç°æ‰“å¼€æµè§ˆå™¨
    print('ğŸŒ Opening URL: $url');

    if (Platform.isMacOS) {
      Process.run('open', [url]);
    } else if (Platform.isWindows) {
      Process.run('cmd', ['/c', 'start', url]);
    } else {
      Process.run('xdg-open', [url]);
    }
  }

  /// æ¸…ç†èµ„æº
  void _cleanup() {
    _statusUpdateTimer?.cancel();
    trayManager.removeListener(this);
    trayManager.destroy();
  }

  /// é”€æ¯æœåŠ¡
  void dispose() {
    _cleanup();
  }
}
